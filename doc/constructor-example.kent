say "Hello, world!";

/* gets you exactly what you'd expect on STDOUT, plus a newline. If you add
   a newline to the end of the string, you'll get a total of two newlines.
   If you use print instead of say, you get zero newlines.
   
   STDIN, STDOUT, and STDERR are filehandles, so if you wrote the previous
   statement out longhand, it would look like this: */

STDOUT.print "Hello, world!\n";

/* All filehandles also have a 'say' method. Choose wisely. Some filehandles
   might default to appending "\r\n" because that's the most appropriate thing
   for them to do. using print with "\n" on those filehandles would be
   defeating their purpose.

/* You can print or say the result of a statement: */

say 2 + 2;

/* This would print "4" and a newline to STDOUT. */

2 + 2;

/* This would do nothing. There's only one time a statement or literal value
   in void context does anything, and that's in a conditional block. More on
   that later.

   You cannot declare an object or variable. You can only construct an object
   by composing a role onto something that doesn't exist yet. "Types" are the
   core, built-in roles that are mostly incompatible with each other.

   What "mostly" means will be covered later. It's complex, but logical. */

three <- Number (3);
drops <- String ("Drops");

/* What's going on here is that we're creating two new objects and passing
   them into constructor for the Types "Number" and "String", respectively,
   with the arguments 3 and "Drops", and composing whatever comes from that
   role onto the respective object.

   this is awkward, so there's literal syntax support for some core types.
   Here are boolean, number, string, hash, and array: */

it_is <- True;
no_is <- False;
three <- 3;
drops <- "Drops";
stuff <- { color => 'red',
           part  => 'nose', };
list  <- [ 1, 2, 3, 4 ];

/* Access object members with a dot. Access array members with square
   braces. */

say stuff.color;   /* says red */
say list[2];       /* says 3, because arrays are zero-indexed */

/* Members and methods are interchangeable. These two are functionally the
   same: */

foo.a <- 4;
foo.a <- () [ return 4 ];

/* Right now, hash keys are strings. If a key would be a valid object
   identifier, it doesn't need to be quoted.
   
   Some other languages allow keying on any object. I can't wrap my head
   around that so I'm not making it so, at least not now. */

stuff.'unit size' <- "8x10";

==============================================================================

/* Nothing in Kent is True or False except for True, False, and objects that
   have explicitlt had True or False composed onto them. Checking the truth
   of something else will throw an exception. */

some_condition <- True;

if (some_condition) [
    string <- "String";
    if (string) [
        /* Kent has just raised an exception, because strings are neither
        True nor False. */
    ]
]

/* "if" is a statement, and the result it yields is returned and can be stored
   directly. */

headgear <- if     (skiing) [ "knit cap" ]
            elseif (rugby)  [ "leather helmet" ]
            else            [ "parasol" ];

/* This is the only time that a statement result or a literal in void context
   goes anywhere.
   
   Kent also has 'unless', and postfix support for both 'if' and 'unless'.
   Unless cannot be used with elseif or else. */

throw "You didn't say 'Simon Says'!" unless simon_said;

/* The most important of the Types are arrays, because all arrays are
   executable ("doable"). All arrays have a .do method, which iterates over
   the array, executing any statements, and returning whatever was explicitly
   returned. If there are no statements, doing the array returns true. Note
   the important distinction: */

[ return 4 ]        /* not True or False */
[ return 4 ].do     /* not True or False */
[ 1, 2 ]            /* not True or False */
[ 1, 2 ].do         /* not True or False */
[ return ].do       /* True */
[ return True ].do  /* True */
[ return False ].do /* False */

/* For this to work, one of Kent's Types is a statement. An array meant to be
   used as a block of code probably only contains statements. (Doing an array
   that contains both statements and non-statements renders the non-statements
   meaningless; they'll just get skipped over. */




load Some::Class;

/* This tells Kent to go through its list of include paths and load only the
   first file /Some/Class.kent it finds, relative to that include path. The
   include paths are stored in an array LIB. I keep my Kent development files
   in my home directory under code/kent/lib, so if I were not thoughtful
   enough, I could add this to the top of all my programs. Note the lack of a
   trailing slash: */

LIB.unshift "~/code/kent/lib";
load Some::Class;

/* But there is a stricture to prevent modifying LIB. I could do this... */

allow modify_LIB;
LIB.unshift "~/code/kent/lib";
load Some::Class;

/* But there's a better way. What you usually want is to add the lib/
   directory that exists in the same directory as the currently running file.
   Kent provides the Pwdlib pseudo-class that just expands to the Present
   Working Directory / lib. This one line loads the file Class.kent from
   lib/Some/ under the directory of the currently-running file. */

load PWD::Some::Class;

/* Man. This syntax is starting to get really weird. */

===============

class Position;

.new ( Number x, Number y, Number z ) {
    new Object self;

    with self {
        .x = x;
        .y = y;
        .z = z;
    }
    return self;
}

.distance {
    return (.x * .x + .y * .y + .z * z) ** .5;
}

.move ( Number dx, Number dy, Number dz ) {
    .x += dx;
    .y += dy;
    .z += dz;
}

class Color;

.new {

}

class TronBit;

.new ( Position pos, Bool state ) {
    new Object self;

    with self {
        .pos   = pos;
        .state = state;
        .color = new Color;

        # Here's one way we could enforce a maximum distance.

        with .pos {
            # throw a conniption if new object would be more than 1km from
            # the origin.
            (.x * .x + .y * .y + .z * .z) ** .5 must < 1000
        }

        # Here's another. We will decorate .pos with a 'distance' numeric
        # method, which returns how far the position object is from the
        # origin.

        .pos.distance.enum = { return (.x * .x + .y * .y + .z * .z); }
        .pos.distance must < 1000;

        if ( .state ) { .color = '#FF0000'; }
        else          { .color = '#0000FF'; }
#        .nistring = 'foo\'bar';
    }
    return self;
}
